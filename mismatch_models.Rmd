---
title: "Modeling mismatched seed traits and microbiome"
author: "Quentin D. Read"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    code_folding: show
---

```{css, echo = FALSE}
.gt_table {
    margin-bottom: 20px;
    margin-top: 20px;
}
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Summary

# Setup

```{r load packages}
library(data.table)
library(brms)
library(ggplot2)
library(ranger)
library(purrr)
library(ALDEx2)

options(mc.cores = 4, brms.backend = 'cmdstanr', brms.file_refit = 'on_change')

# Import data. Corrected labels, data accessed from g drive 2023-06-06
abundance <- fread('project/data/16S_abundance.csv')
traits <- fread('project/data/seedling_data_updated.csv')
```

```{r ggplot theme, include = FALSE}
windowsFonts(`fgbook` = windowsFont('Franklin Gothic Book'))
theme_set(
  theme_bw(base_family = 'fgbook') + 
    theme(panel.grid = element_blank(),
          strip.background = element_blank())
)
```

# Trait model

Fit a very simple linear mixed model to a single trait (rooting depth in cm). All default priors are used.

```{r}
rdepthfit <- brm(rooting_depth_cm ~ country_origin + (1 | maternal_plant_code), data = traits,
                 chains = 4, iter = 2000, warmup = 1000, seed = 836,
                 file = 'project/fits/rdepthfit')
```

Extract the posterior distribution of the BLUPs for each of the 9 maternal plants (rooting depth data was missing for the 10th plant). If you add the fixed and random effect together you get a predicted value for each maternal plant for each of the 4000 posterior samples, so this is a 4000x9 matrix.

```{r}
pred_grid <- unique(traits[!is.na(rooting_depth_cm), .(maternal_plant_code, country_origin)])

rdepth_post_blups <- predict(rdepthfit, newdata = pred_grid, summary = FALSE)
```

# Option 1: use aggregated microbiome to predict traits

This is a "quick and dirty" method. Aggregate the microbiome samples by maternal plant by summing the counts up. This will be a reasonably good estimate of the "mean" microbiome from each maternal plant but will not account for the uncertainty resulting from us being only able to obliquely observe the maternal microbiome through sampling the microbiomes of its offspring.

Convert abundance data to longform and then create identifier columns for sample ID and maternal plant code. Sum the counts and then convert to a wideform with taxa as columns.

```{r}
abundance_long <- melt(abundance, id.vars = 'V1') 
abundance_long[, maternal_plant_code := substr(variable, 3, 3)]
abundance_long[, sampleID := substr(variable, 1, 2)]

abundance_wide <- dcast(abundance_long,  maternal_plant_code + sampleID ~ V1)

abundance_agg <- abundance_long[, .(value = sum(value)), by = .(V1, maternal_plant_code)]
abundance_agg_wide <- dcast(abundance_agg,  maternal_plant_code ~ V1)
```

Subset the aggregated data to get rid of maternal plant J which does not have rooting depth data.

```{r}
abundance_agg_forfitting <- abundance_agg_wide[maternal_plant_code %in% pred_grid$maternal_plant_code]
```

Define function to fit the random forest for a single posterior sample. 

```{r}
fit_rf <- function(y) {
  y <- data.table(maternal_plant_code = pred_grid$maternal_plant_code, y = y)
  dt <- y[abundance_agg_forfitting, on = .(maternal_plant_code)]
  dt[, maternal_plant_code := NULL]
  setnames(dt, c('y', paste0('otu', 1:(ncol(dt)-1)))) # Must do this because the OTU names are not valid column names.
  rf <- ranger(y ~ ., data = dt, min.node.size = 3, num.trees = 1000)
}
```

Apply the function to a random subset of 100 of the posterior samples.

> note: It would be easy to parallelize this if it becomes necessary later, to more easily work with more posterior samples.

```{r}
set.seed(1104)
rdepth_post_blups_subsample <- rdepth_post_blups[sample(1:nrow(rdepth_post_blups), 100), ]

post_rf_fits <- apply(rdepth_post_blups_subsample, 1, fit_rf)
```

Examine the out-of-bag R-squared values for all 100 posterior samples.

```{r}
rsqs <- map_dbl(post_rf_fits, 'r.squared')
ggplot(data.frame(rsq = rsqs), aes(x = rsq)) +
  geom_histogram() +
  geom_vline(xintercept = mean(rsqs), color = 'red')
```

It is very poor performance: almost all the out of bag r-squared values are <0 and the mean is about -0.2, indicating that the model using microbiome to predict traits (after adjusting for maternal plant identity and country of origin using the linear mixed model) is even worse than just predicting that every individual has the average trait.

# Option 2: use distribution from Aldex2 model to predict traits

Here we generate 1000 MC samples, later downsampled to 100 for demonstration purposes. This can be increased. It may be possible to parallelize. A test is not done, just the step where Monte Carlo samples of the Dirichlet distribution from each sample are generated ([part 4.1 in the vignette](https://bioconductor.org/packages/release/bioc/vignettes/ALDEx2/inst/doc/ALDEx2_vignette.html#41_The_aldexclr_module)).

```{r}
aldexsamples <- aldex.clr(abundance[, -1], abundance_wide$maternal_plant_code, mc.samples = 1000)
aldexeff <- aldex.effect(aldexsamples)
```

